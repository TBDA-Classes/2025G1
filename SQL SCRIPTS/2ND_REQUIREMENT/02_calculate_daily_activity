/* ===============================================================
   PURPOSE: Compute daily machine activity metrics (running vs stopped)
   using the variable MACHINE_STOP_ACTIVE (id_var = 660).

   CONTEXT:
   Each log in variable_log_float records the machine state (0 or 1)
   at a given timestamp. We compute how long the machine stays
   in each state per day, then derive total uptime and downtime.

   OUTPUT:
   - running_hours : hours where state = 1
   - stopped_hours : hours where state = 0
   - total_hours   : total recorded hours
   - uptime_ratio  : running_hours / total_hours
==================================================================*/

WITH ordered AS (
  SELECT
    ts_utc,
    day,
    value::integer AS state,
    LEAD(ts_utc) OVER (ORDER BY ts_utc) AS next_ts
  FROM v_log_float
  WHERE id_var = 660 AND value IN (0,1)
),
intervals AS (
  SELECT
    day,
    state,
    EXTRACT(EPOCH FROM (COALESCE(next_ts, ts_utc) - ts_utc)) AS duration_s
  FROM ordered
  WHERE next_ts IS NOT NULL
)
SELECT
  day,
  ROUND(SUM(CASE WHEN state = 1 THEN duration_s ELSE 0 END)/3600,2) AS running_hours,
  ROUND(SUM(CASE WHEN state = 0 THEN duration_s ELSE 0 END)/3600,2) AS stopped_hours,
  ROUND(SUM(duration_s)/3600,2) AS total_hours,
  ROUND(SUM(CASE WHEN state = 1 THEN duration_s ELSE 0 END) / NULLIF(SUM(duration_s),0),3) AS uptime_ratio
FROM intervals
GROUP BY day
ORDER BY day;
