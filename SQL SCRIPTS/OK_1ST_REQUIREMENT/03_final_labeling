-- PURPOSE: Calculate the TOTAL time spent in each of the three states (Idle, Intermediate, Active) across the ENTIRE dataset.
-- METHODOLOGY: Uses COUNT(DISTINCT active variables) per second and K-Means derived thresholds. Aggregates the final durations.
-- THRESHOLDS (from 2021-03-18 K-Means): Idle <= 17, Intermediate <= 24, Active > 24.

WITH RelevantDataTimeRange AS (
    -- Pre-calculate the absolute minimum and maximum timestamp across the entire table.
    SELECT
        MIN(to_timestamp(floor(CAST(date AS BIGINT) / 1000))) as min_ts,
        MAX(to_timestamp(floor(CAST(date AS BIGINT) / 1000))) as max_ts
    FROM public.variable_log_float
),
VariablesPerSecond AS (
    -- 1. Get distinct variables per second across ALL time.
    SELECT
        to_timestamp(floor(CAST(date AS BIGINT) / 1000)) AS timestamp,
        id_var
    FROM
        public.variable_log_float
    -- No date filter here
    GROUP BY
        timestamp, id_var
),
DistinctCountPerSecond AS (
    -- 2. Calculate COUNT(DISTINCT id_var) per second.
    SELECT
        timestamp,
        COUNT(id_var) AS distinct_vars_count
    FROM
        VariablesPerSecond
    GROUP BY
        timestamp
),
InstantaneousStates AS (
    -- 3. Assign state label and number based on K-Means derived thresholds.
    SELECT
        timestamp,
        CASE
            WHEN distinct_vars_count <= 17 THEN 'Idle'           -- K-Means Threshold 1
            WHEN distinct_vars_count <= 24 THEN 'Intermediate'    -- K-Means Threshold 2
            ELSE 'Active'
        END AS state_label,
        CASE
            WHEN distinct_vars_count <= 17 THEN 0 -- Idle
            WHEN distinct_vars_count <= 24 THEN 1 -- Intermediate
            ELSE 2 -- Active
        END AS state_num
    FROM
        DistinctCountPerSecond
),
StateChanges AS (
    -- Helper CTE to identify just the state change points
     SELECT timestamp, state_num, state_label
     FROM (
         SELECT timestamp, state_num, state_label, LAG(state_num, 1, -1) OVER (ORDER BY timestamp) AS previous_state_num
         FROM InstantaneousStates
     ) AS Subquery
     WHERE state_num <> previous_state_num
),
PeriodStarts AS (
    -- 4. Combine actual state change points with the very first timestamp if needed.
     SELECT timestamp, state_num, state_label FROM StateChanges
     UNION ALL
     -- Ensure the very first timestamp is included as a starting point if it wasn't a change point
     SELECT min_ts, initial_state_num, initial_state_label
     FROM RelevantDataTimeRange,
          (SELECT state_num as initial_state_num, state_label as initial_state_label FROM InstantaneousStates ORDER BY timestamp LIMIT 1) AS FirstState
     WHERE NOT EXISTS (SELECT 1 FROM StateChanges sc WHERE sc.timestamp = min_ts)
),
DetailedPeriods AS (
     -- 5. Build the detailed list of periods with durations, using dynamic end time.
     SELECT
        state_label AS state,
        LEAD(timestamp, 1, (SELECT max_ts + interval '1 second' FROM RelevantDataTimeRange)) OVER (ORDER BY timestamp) - timestamp AS duration
     FROM
        PeriodStarts
)
-- FINAL STEP: Aggregate the detailed periods to get the total time for each state across all data.
SELECT
    state,
    SUM(duration) as total_duration
FROM
    DetailedPeriods
GROUP BY
    state;