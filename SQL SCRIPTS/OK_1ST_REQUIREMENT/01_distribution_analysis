# -*- coding: utf-8 -*-
"""
Created on Mon Oct 20 22:32:23 2025

@author: jairi
"""
#K-Means clustering algorithm to statistically determine the best thresholds for classifying the 
# machine's state into Idle, Intermediate, and Active, based on how many different sensors are active each second.
# IMPORT LIBRARIES
import pandas as pd
from sklearn.cluster import KMeans
import numpy as np
import matplotlib.pyplot as plt # Import for plotting

# LOAD DATA
# Load the per-second distinct counts from the CSV generated by SQL.
# Assumes the CSV is in a 'data' subfolder relative to this script.
try:
    file_path = "data/ok_1st_req/distinct_counts_per_second.csv"
    df = pd.read_csv(file_path)
    # Reshape data for K-Means (needs to be a 2D array)
    data = df['distinct_vars_count'].values.reshape(-1, 1)
except FileNotFoundError:
    print(f"Error: CSV file not found at {file_path}")
    print("Please make sure 'distinct_counts_per_second.csv' is inside a 'data/ok_1st_req' subfolder.")
    data = None
except KeyError:
    print(f"Error: CSV file must contain a column named 'distinct_vars_count'")
    data = None

# APPLY K-MEANS
if data is not None:
    # Apply K-Means to find 3 clusters (Idle, Intermediate, Active)
    kmeans = KMeans(n_clusters=3, random_state=42, n_init=10) # Set n_init explicitly
    kmeans.fit(data)

    # GET CENTROIDS
    # Get the centroids (average distinct_vars_count for each cluster)
    centroids = np.sort(kmeans.cluster_centers_.flatten())
    print(f"Cluster Centroids (Avg. distinct count per state): {centroids}")

    # CALCULATE THRESHOLDS
    # Thresholds are the midpoints between sorted centroids
    threshold1 = (centroids[0] + centroids[1]) / 2
    threshold2 = (centroids[1] + centroids[2]) / 2

    print(f"\nStatistically determined thresholds:")
    print(f"Threshold 1 (Idle vs Intermediate): {threshold1:.2f}")
    print(f"Threshold 2 (Intermediate vs Active): {threshold2:.2f}")

    # DEFINE STATES BASED ON THRESHOLDS (Using integer boundaries)
    thresh1_int = int(np.floor(threshold1)) # Use floor for the upper bound of Idle
    thresh2_int = int(np.floor(threshold2)) # Use floor for the upper bound of Intermediate

    print("\nProposed State Definitions (Integer Thresholds):")
    print(f"Idle: distinct_vars_count <= {thresh1_int}")
    print(f"Intermediate: {thresh1_int} < distinct_vars_count <= {thresh2_int}")
    print(f"Active: distinct_vars_count > {thresh2_int}")

    # VISUALIZE CLUSTERS 
    plt.figure(figsize=(10, 6))
    # Create histogram data
    counts, bins, _ = plt.hist(df['distinct_vars_count'], bins=range(int(df['distinct_vars_count'].min()), int(df['distinct_vars_count'].max()) + 2), alpha=0.5, label='Frequency Distribution')
    plt.close() # Close the histogram plot, we only needed the data

    bin_centers = 0.5 * (bins[:-1] + bins[1:])
    plt.plot(bin_centers, counts, marker='o', linestyle='-', label='Frequency of Distinct Counts')

    # Plot centroids and thresholds
    plt.scatter(centroids, [max(counts)*0.1]*len(centroids), c='red', s=100, marker='X', label='Cluster Centroids')
    plt.axvline(x=threshold1, color='green', linestyle='--', label=f'Threshold 1 ({threshold1:.1f})')
    plt.axvline(x=threshold2, color='purple', linestyle='--', label=f'Threshold 2 ({threshold2:.1f})')

    plt.title('Distinct Variable Count Distribution with K-Means Thresholds')
    plt.xlabel('Number of Distinct Active Variables per Second')
    plt.ylabel('Number of Seconds')
    plt.grid(True)
    plt.legend()
    plt.show()
