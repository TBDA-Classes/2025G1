-- Here we aim to identify working periods based on a simultaneous change of multiple key indicators.
-- The state is 'WORKING' if more than a threshold number of key sensors change their value in a given second.

WITH PivotedValues AS (
    -- 1. Select and pivot the ~16 most relevant activity variables.
    SELECT
        to_timestamp(floor(CAST(date AS BIGINT) / 1000)) AS timestamp,
        -- Load / Effort
        MAX(CASE WHEN id_var = 544 THEN value END) AS spindle_load,
        MAX(CASE WHEN id_var = 630 THEN value END) AS spindle_consumption,
        -- Motor Utilization
        MAX(CASE WHEN id_var = 537 THEN value END) AS axis_x_util,
        MAX(CASE WHEN id_var = 498 THEN value END) AS axis_y_util,
        MAX(CASE WHEN id_var = 620 THEN value END) AS axis_z_util,
        MAX(CASE WHEN id_var = 565 THEN value END) AS axis_5_util,
        MAX(CASE WHEN id_var = 584 THEN value END) AS axis_8_util,
        -- Speed and Feed Rate
        MAX(CASE WHEN id_var = 550 THEN value END) AS spindle_rpm, -- Assumed from previous context
        MAX(CASE WHEN id_var = 587 THEN value END) AS feed_rapid_active,
        MAX(CASE WHEN id_var = 606 THEN value END) AS feed_contour,
        -- Movement Status
        MAX(CASE WHEN id_var = 601 THEN value END) AS axis_x_moving,
        MAX(CASE WHEN id_var = 501 THEN value END) AS axis_y_moving,
        MAX(CASE WHEN id_var = 458 THEN value END) AS axis_z_moving,
        MAX(CASE WHEN id_var = 619 THEN value END) AS axis_x_in_position,
        MAX(CASE WHEN id_var = 609 THEN value END) AS axis_y_in_position,
        MAX(CASE WHEN id_var = 614 THEN value END) AS axis_z_in_position
    FROM
        public.variable_log_float
    WHERE
        id_var IN (544, 630, 537, 498, 620, 565, 584, 550, 587, 606, 601, 501, 458, 619, 609, 614)
        AND to_timestamp(CAST(date AS BIGINT) / 1000) BETWEEN '2021-01-04 06:00:00' AND '2021-01-04 22:00:00'
    GROUP BY
        1
),
ActivityScore AS (
    -- 2. Calculate the "Activity Score" by counting how many variables changed from the previous second.
    SELECT
        timestamp,
        (CASE WHEN spindle_load <> LAG(spindle_load) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_consumption <> LAG(spindle_consumption) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_util <> LAG(axis_x_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_util <> LAG(axis_y_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_util <> LAG(axis_z_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_5_util <> LAG(axis_5_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_8_util <> LAG(axis_8_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_rpm <> LAG(spindle_rpm) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_rapid_active <> LAG(feed_rapid_active) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_contour <> LAG(feed_contour) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_moving <> LAG(axis_x_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_moving <> LAG(axis_y_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_moving <> LAG(axis_z_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_in_position <> LAG(axis_x_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_in_position <> LAG(axis_y_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_in_position <> LAG(axis_z_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END)
        AS activity_score
    FROM
        PivotedValues
),
InstantaneousStates AS (
    -- 3. Assign the 'WORKING' state (1) if the activity score exceeds a threshold.
    -- This threshold (> 12) is an ARBITRARY STARTIING POINT and should be tuned by analyzing the activity_score.
    SELECT
        timestamp,
        CASE WHEN activity_score > 12 THEN 1 ELSE 0 END AS state_num
    FROM
        ActivityScore
),
PeriodStarts AS (
    -- 4. Identify only the moments when the state changes (no changes to this logic).
    SELECT
        timestamp,
        state_num
    FROM (
        SELECT
            timestamp,
            state_num,
            LAG(state_num, 1, -1) OVER (ORDER BY timestamp) AS previous_state
        FROM
            InstantaneousStates
    ) AS Subquery
    WHERE
        state_num <> previous_state
)
-- 5. Build the final periods table with durations (no changes to this logic).
SELECT
    CASE WHEN state_num = 1 THEN 'WORKING' ELSE 'STOPPED' END AS state,
    timestamp AS period_start,
    LEAD(timestamp, 1, '2021-01-04 22:00:00') OVER (ORDER BY timestamp) AS period_end,
    LEAD(timestamp, 1, '2021-01-04 22:00:00') OVER (ORDER BY timestamp) - timestamp AS duration
FROM
    PeriodStarts;