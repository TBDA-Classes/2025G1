-- On our first estimation to label the states of the machines through this new method, we found that our initial threshold of >12 was too high, 
-- resulting in a very restrictive definition of 'WORKING' that only captured the brief moments of massive state change, not continuous work.
-- So doing the following analysis allows us to find a data-driven threshold by observing the natural distribution of the scores.

-- Here we only calculate the activity score for each second and count how many times each score occurs, analysis is done outside SQL.
-- this SQL query counts the occurrences of each activity score from 0 to 16. Out of the total seconds in that workday (from 06:00 to 22:00), 
--the script calculated, on a per-second basis, the number of selected variables (out of 16) that had changed their value compared to the one before.
-- find the output on the data folder as activity_score_distribution.csv

WITH PivotedValues AS (
    -- 16 variables considered
    SELECT
        to_timestamp(floor(CAST(date AS BIGINT) / 1000)) AS timestamp,
        MAX(CASE WHEN id_var = 544 THEN value END) AS spindle_load, MAX(CASE WHEN id_var = 630 THEN value END) AS spindle_consumption,
        MAX(CASE WHEN id_var = 537 THEN value END) AS axis_x_util, MAX(CASE WHEN id_var = 498 THEN value END) AS axis_y_util,
        MAX(CASE WHEN id_var = 620 THEN value END) AS axis_z_util, MAX(CASE WHEN id_var = 565 THEN value END) AS axis_5_util,
        MAX(CASE WHEN id_var = 584 THEN value END) AS axis_8_util, MAX(CASE WHEN id_var = 550 THEN value END) AS spindle_rpm,
        MAX(CASE WHEN id_var = 587 THEN value END) AS feed_rapid_active, MAX(CASE WHEN id_var = 606 THEN value END) AS feed_contour,
        MAX(CASE WHEN id_var = 601 THEN value END) AS axis_x_moving, MAX(CASE WHEN id_var = 501 THEN value END) AS axis_y_moving,
        MAX(CASE WHEN id_var = 458 THEN value END) AS axis_z_moving, MAX(CASE WHEN id_var = 619 THEN value END) AS axis_x_in_position,
        MAX(CASE WHEN id_var = 609 THEN value END) AS axis_y_in_position, MAX(CASE WHEN id_var = 614 THEN value END) AS axis_z_in_position
    FROM public.variable_log_float
    WHERE id_var IN (544, 630, 537, 498, 620, 565, 584, 550, 587, 606, 601, 501, 458, 619, 609, 614)
    AND to_timestamp(CAST(date AS BIGINT) / 1000) BETWEEN '2021-01-04 06:00:00' AND '2021-01-04 22:00:00'
    GROUP BY 1
),
ActivityScore AS (
    -- 2. Calculate the auxiliar metric
    SELECT
        timestamp,
        (CASE WHEN spindle_load <> LAG(spindle_load) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_consumption <> LAG(spindle_consumption) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_util <> LAG(axis_x_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_util <> LAG(axis_y_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_util <> LAG(axis_z_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_5_util <> LAG(axis_5_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_8_util <> LAG(axis_8_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_rpm <> LAG(spindle_rpm) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_rapid_active <> LAG(feed_rapid_active) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_contour <> LAG(feed_contour) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_moving <> LAG(axis_x_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_moving <> LAG(axis_y_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_moving <> LAG(axis_z_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_in_position <> LAG(axis_x_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_in_position <> LAG(axis_y_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_in_position <> LAG(axis_z_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END)
        AS activity_score
    FROM PivotedValues
)
-- 3. Count the occurrences of each activity score.
SELECT
    activity_score,
    COUNT(*) AS number_of_seconds
FROM
    ActivityScore
GROUP BY
    activity_score
ORDER BY
    activity_score DESC;

--    
