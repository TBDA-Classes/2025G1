-- Here we calculate the TOTAL time spent in each state ('WORKING' / 'STOPPED') using the validated change-point detection method.
-- This query first calculates all individual working/stopped segments using the statistically validated 'activity_score > 4' threshold. 
-- It then aggregates these segments to produce a final summary of total durations.

WITH PivotedValues AS (
    -- 1. Select and pivot the 16 most relevant activity variables.
    SELECT
        to_timestamp(floor(CAST(date AS BIGINT) / 1000)) AS timestamp,
        MAX(CASE WHEN id_var = 544 THEN value END) AS spindle_load, MAX(CASE WHEN id_var = 630 THEN value END) AS spindle_consumption,
        MAX(CASE WHEN id_var = 537 THEN value END) AS axis_x_util, MAX(CASE WHEN id_var = 498 THEN value END) AS axis_y_util,
        MAX(CASE WHEN id_var = 620 THEN value END) AS axis_z_util, MAX(CASE WHEN id_var = 565 THEN value END) AS axis_5_util,
        MAX(CASE WHEN id_var = 584 THEN value END) AS axis_8_util, MAX(CASE WHEN id_var = 550 THEN value END) AS spindle_rpm,
        MAX(CASE WHEN id_var = 587 THEN value END) AS feed_rapid_active, MAX(CASE WHEN id_var = 606 THEN value END) AS feed_contour,
        MAX(CASE WHEN id_var = 601 THEN value END) AS axis_x_moving, MAX(CASE WHEN id_var = 501 THEN value END) AS axis_y_moving,
        MAX(CASE WHEN id_var = 458 THEN value END) AS axis_z_moving, MAX(CASE WHEN id_var = 619 THEN value END) AS axis_x_in_position,
        MAX(CASE WHEN id_var = 609 THEN value END) AS axis_y_in_position, MAX(CASE WHEN id_var = 614 THEN value END) AS axis_z_in_position
    FROM
        public.variable_log_float
    WHERE
        id_var IN (544, 630, 537, 498, 620, 565, 584, 550, 587, 606, 601, 501, 458, 619, 609, 614)
        AND to_timestamp(CAST(date AS BIGINT) / 1000) BETWEEN '2021-01-04 06:00:00' AND '2021-01-04 22:00:00'
    GROUP BY
        1
),
ActivityScore AS (
    -- 2. Calculate the "Activity Score" by counting how many variables changed.
    SELECT
        timestamp,
        (CASE WHEN spindle_load <> LAG(spindle_load) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_consumption <> LAG(spindle_consumption) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_util <> LAG(axis_x_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_util <> LAG(axis_y_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_util <> LAG(axis_z_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_5_util <> LAG(axis_5_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_8_util <> LAG(axis_8_util) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN spindle_rpm <> LAG(spindle_rpm) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_rapid_active <> LAG(feed_rapid_active) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN feed_contour <> LAG(feed_contour) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_moving <> LAG(axis_x_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_moving <> LAG(axis_y_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_moving <> LAG(axis_z_moving) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_x_in_position <> LAG(axis_x_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_y_in_position <> LAG(axis_y_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END) +
        (CASE WHEN axis_z_in_position <> LAG(axis_z_in_position) OVER (ORDER BY timestamp) THEN 1 ELSE 0 END)
        AS activity_score
    FROM
        PivotedValues
),
InstantaneousStates AS (
    -- 3. Assign the 'WORKING' state (1) using the statistically validated threshold.
    SELECT
        timestamp,
        CASE WHEN activity_score > 4 THEN 1 ELSE 0 END AS state_num
    FROM
        ActivityScore
),
PeriodStarts AS (
    -- 4. Identify only the moments when the state changes.
    SELECT
        timestamp,
        state_num
    FROM (
        SELECT
            timestamp,
            state_num,
            LAG(state_num, 1, -1) OVER (ORDER BY timestamp) AS previous_state
        FROM
            InstantaneousStates
    ) AS Subquery
    WHERE
        state_num <> previous_state
),
DetailedPeriods AS (
    -- 5. Build the detailed list of all periods with their durations.
    SELECT
        CASE WHEN state_num = 1 THEN 'WORKING' ELSE 'STOPPED' END AS state,
        LEAD(timestamp, 1, '2021-01-04 22:00:00') OVER (ORDER BY timestamp) - timestamp AS duration
    FROM
        PeriodStarts
)
-- FINAL STEP: Aggregate the detailed periods to get the total time for each state.
SELECT
    state,
    SUM(duration) as total_duration
FROM
    DetailedPeriods
GROUP BY
    state;

-- The sum of the times (13:16:16 + 01:49:26 = 15:05:42) does not add up to 16 hours 
-- because there was a period at the beginning of the day with no data records. The 
-- script starts calculating the periods from the first data record it finds after 06:00:00.
-- If there is no data from the 16 selected variables between 06:00:00 and, for example, 06:54:18, 
-- that entire initial period (54 minutes and 18 seconds) is left out of the calculation.
-- find the output on the data folder as Total_duration_1day.xlsx
-- once it is validated, this logic can be applied to the entire dataset.