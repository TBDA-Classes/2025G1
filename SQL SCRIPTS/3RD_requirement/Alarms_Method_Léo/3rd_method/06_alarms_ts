-- This SQL script extracts all machine alarms recorded in variable 447.
-- It parses the JSON-like alarm messages, reconstructs continuous alarm periods,
-- and returns the alarm start time, duration, and reason for a selected 10-day window.
-- Output: ts (start), duration, and the complete alarm description (code + text).

WITH raw AS (
    -- 1) Select only variable 447 in the 10-day window
    SELECT
        to_timestamp(date/1000) AS ts,
        value,
        LEAD(to_timestamp(date/1000)) OVER (ORDER BY date) AS next_ts
    FROM variable_log_string
    WHERE id_var = 447
      AND to_timestamp(date/1000) 
            BETWEEN '2021-02-26' AND '2021-03-08'  -- <<< PUT YOUR 10-DAY RANGE HERE
),

flat AS (
    -- 2) Extract each alarm inside the JSON string
    SELECT
        r.ts,
        r.next_ts,
        (m)[1] AS alarm_code,
        (m)[2] AS alarm_text
    FROM raw r
    CROSS JOIN LATERAL regexp_matches(
        r.value,
        '\["([^"]+)","([^"]+)",([0-9]+),([0-9]+),([0-9]+)\]',
        'g'
    ) AS m
    WHERE r.next_ts IS NOT NULL
),

segments AS (
    -- 3) Compute segments and group continuous alarms
    SELECT
        alarm_code,
        alarm_text,
        ts,
        next_ts,
        LAG(next_ts) OVER (PARTITION BY alarm_code, alarm_text ORDER BY ts) AS prev_end
    FROM flat
),

marked AS (
    SELECT
        *,
        CASE WHEN prev_end IS NULL OR prev_end < ts THEN 1 ELSE 0 END AS new_group
    FROM segments
),

islands AS (
    SELECT
        *,
        SUM(new_group) OVER (PARTITION BY alarm_code, alarm_text ORDER BY ts) AS grp
    FROM marked
),

periods AS (
    -- 4) Aggregate into alarm periods
    SELECT
        alarm_code,
        alarm_text,
        MIN(ts) AS start_time,
        MAX(next_ts) AS end_time
    FROM islands
    GROUP BY alarm_code, alarm_text, grp
)

-- ⭐️ RESULT : timestamp + duration + reason
SELECT
    start_time AS ts,
    end_time - start_time AS duration,
    alarm_code || ' - ' || alarm_text AS reason
FROM periods
ORDER BY start_time;
