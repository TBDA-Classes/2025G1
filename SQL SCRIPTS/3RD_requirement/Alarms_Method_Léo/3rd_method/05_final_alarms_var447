-- ============================================================================
--  ALARM RECONSTRUCTION & STATISTICS (from variable 447 - string alarms)
--
--  This script parses all encoded alarm messages stored in variable 447,
--  rebuilds continuous alarm periods (so repeated entries are merged), and
--  computes aggregated statistics: number of occurrences, total duration,
--  and average duration per alarm type.
--
--  Output = one row per unique alarm_code + alarm_text with full metrics.
-- ============================================================================


WITH alarm_snapshots AS (
    -- All snapshots of ALARMS (id = 447)
    SELECT
        to_timestamp(date/1000) AS ts,
        value
    FROM variable_log_string
    WHERE id_var = 447
),

snapshots_with_next AS (
    -- Add next timestamp to compute segment duration
    SELECT
        ts,
        value,
        LEAD(ts) OVER (ORDER BY ts) AS next_ts
    FROM alarm_snapshots
),

alarms_flat AS (
    -- Expand parsed alarms inside each JSON-like list
    SELECT
        s.ts,
        s.next_ts,
        (m)[1] AS alarm_code,
        (m)[2] AS alarm_text,
        (m)[3]::int AS field_3,
        (m)[4]::int AS field_4,
        (m)[5]::bigint AS field_5
    FROM snapshots_with_next s
    CROSS JOIN LATERAL regexp_matches(
        s.value,
        '\["([^"]+)","([^"]+)",([0-9]+),([0-9]+),([0-9]+)\]',
        'g'
    ) AS m
    WHERE s.next_ts IS NOT NULL
),

segments AS (
    -- Single snapshot segments grouped into continuous alarm periods
    SELECT
        alarm_code,
        alarm_text,
        field_3, field_4, field_5,
        ts,
        next_ts,
        LAG(next_ts) OVER (
            PARTITION BY alarm_code, alarm_text
            ORDER BY ts
        ) AS prev_end
    FROM alarms_flat
),

marked AS (
    -- Mark start of a new alarm period
    SELECT
        *,
        CASE
            WHEN prev_end IS NULL OR prev_end < ts THEN 1 ELSE 0
        END AS is_new_group
    FROM segments
),

islands AS (
    -- Build groups of continuous alarm segments ("islands")
    SELECT
        *,
        SUM(is_new_group) OVER (
            PARTITION BY alarm_code, alarm_text
            ORDER BY ts
        ) AS grp
    FROM marked
),

alarm_periods AS (
    -- Aggregate by period
    SELECT
        alarm_code,
        alarm_text,
        field_3, field_4, field_5,
        MIN(ts) AS start_time,
        MAX(next_ts) AS end_time,
        SUM(next_ts - ts) AS raw_duration
    FROM islands
    GROUP BY alarm_code, alarm_text, field_3, field_4, field_5, grp
)

-- FINAL OUTPUT
SELECT
    alarm_code,
    alarm_text,
    COUNT(*) AS nb_occurrences,
    SUM(raw_duration) AS total_duration,
    AVG(raw_duration) AS average_duration
FROM alarm_periods
GROUP BY alarm_code, alarm_text
ORDER BY nb_occurrences DESC;
