-- This was our first approximation to Identify operation periods and working segments, however,
-- it is not very robust and we changed it to the one in 03_OK_first_labeling

-- The machine is working if the spindle_load
-- exceeds a threshold AND at least one of the main axes (X, Y, or Z) is in motion.
-- WORKING IF: SPINDLE_LOAD > 3 AND (X, Y, or Z AXIS IS MOVING).
-- 4 January 2021 from 6 am to 10pm (sample for testing)


WITH ValuesPerSecond AS (
    -- 1. Pivot key sensor data to have one row per second.
    SELECT
        to_timestamp(floor(CAST(date AS BIGINT) / 1000)) AS timestamp,
        MAX(CASE WHEN id_var = 544 THEN value END) AS spindle_load,
        MAX(CASE WHEN id_var = 601 THEN value END) AS axis_x_mov,
        MAX(CASE WHEN id_var = 501 THEN value END) AS axis_y_mov,
        MAX(CASE WHEN id_var = 458 THEN value END) AS axis_z_mov
    FROM
        public.variable_log_float
    WHERE
        id_var IN (544, 601, 501, 458) -- IDs for SPINDLE_LOAD and axis movement
        AND to_timestamp(CAST(date AS BIGINT) / 1000) BETWEEN '2021-01-04 06:00:00' AND '2021-01-04 22:00:00'
    GROUP BY
        1
),
InstantaneousStates AS (
    -- 2. Assign a state based on the rule. A movement value > 0 indicates activity.
    SELECT
        timestamp,
        CASE
            WHEN spindle_load > 3 AND (axis_x_mov > 0 OR axis_y_mov > 0 OR axis_z_mov > 0) THEN 1
            ELSE 0
        END AS state_num
    FROM
        ValuesPerSecond
),
PeriodStarts AS (
    -- 3. Identify only the moments when the state changes.
    SELECT
        timestamp,
        state_num
    FROM (
        SELECT
            timestamp,
            state_num,
            LAG(state_num, 1, -1) OVER (ORDER BY timestamp) AS previous_state
        FROM
            InstantaneousStates
    ) AS Subquery
    WHERE
        state_num <> previous_state
)
-- 4. Build the periods and calculate the duration for each.
SELECT
    CASE WHEN state_num = 1 THEN 'WORKING' ELSE 'STOPPED' END AS state,
    timestamp AS period_start,
    LEAD(timestamp, 1, '2021-01-04 22:00:00') OVER (ORDER BY timestamp) AS period_end,
    LEAD(timestamp, 1, '2021-01-04 22:00:00') OVER (ORDER BY timestamp) - timestamp AS duration
FROM
    PeriodStarts;